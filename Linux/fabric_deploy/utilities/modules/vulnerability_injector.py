"""
Vulnerability Injector Module for CCDC framework
Creates system misconfigurations and "bad" state for testing hardening modules.
Supports Linux, BSD (FreeBSD, OpenBSD, NetBSD), and macOS.
"""

import logging
from typing import List
from .base import HardeningModule, HardeningCommand, PythonAction, HardeningResult
from ..actions import UserManager
from ..discovery import OSFamily

logger = logging.getLogger(__name__)

# BSD-like OS families
BSD_FAMILIES = [OSFamily.FREEBSD, OSFamily.OPENBSD, OSFamily.NETBSD, OSFamily.BSDGENERIC]
# Linux OS families
LINUX_FAMILIES = [OSFamily.DEBIAN, OSFamily.REDHAT, OSFamily.SUSE, OSFamily.ARCH, OSFamily.ALPINE, OSFamily.SLACKWARE]


class VulnerabilityInjectorModule(HardeningModule):
    """
    Injects vulnerabilities and misconfigurations into the system.
    Used for testing the effectiveness of hardening modules.
    Supports Linux, BSD, and macOS platforms.
    """

    def __init__(self, connection, server_info, os_family):
        super().__init__(connection, server_info, os_family)
        self.user_manager = UserManager(
            server_info.available_commands,
            server_info.groups,
            server_info.sudoers_info,
        )
        self._available_commands = set(server_info.available_commands or [])

    def _has_cmd(self, cmd: str) -> bool:
        """Check if a command is available on this system."""
        return cmd in self._available_commands

    def get_name(self) -> str:
        return "vulnerability_injector"

    def get_commands(self) -> List[HardeningCommand]:
        commands = []

        # 1. user_hardening: Create bad users and sudoers (cross-platform via PythonAction)
        commands.append(PythonAction(
            function=self._create_hacker_user,
            description="Create 'hacker' user with weak password",
            requires_sudo=True
        ))

        commands.append(PythonAction(
            function=self._add_hacker_sudoers,
            description="Give 'hacker' NOPASSWD sudo access",
            requires_sudo=True
        ))

        # 2. ssh_hardening: Weaken sshd_config (cross-platform)
        commands.append(PythonAction(
            function=self._weaken_ssh_config,
            description="Weaken SSH configuration (PermitRootLogin, PasswordAuth)",
            requires_sudo=True
        ))

        commands.append(PythonAction(
            function=self._reload_ssh,
            description="Reload SSH to apply insecure config",
            requires_sudo=True
        ))

        # 3. firewall_hardening: Flush rules (cross-platform)
        commands.append(PythonAction(
            function=self._flush_firewall,
            description="Flush all firewall rules (Open Policy)",
            requires_sudo=True
        ))

        # 4. package_installer: Uninstall critical tools (cross-platform)
        commands.append(PythonAction(
            function=self._remove_audit_tools,
            description="Uninstall auditd/audit tools (if present)",
            requires_sudo=True
        ))

        # 5. logging_setup: Break logging config
        commands.append(PythonAction(
            function=self._disable_logging_config,
            description="Disable CCDC logging configuration",
            requires_sudo=True
        ))

        # 6. agent_account: Remove scan-agent (cross-platform)
        commands.append(PythonAction(
            function=self._remove_scan_agent,
            description="Remove scan-agent account",
            requires_sudo=True
        ))

        return commands

    # =========================================================================
    # User Injection (Cross-Platform)
    # =========================================================================

    def _create_hacker_user(self, conn, server_info) -> HardeningResult:
        """Create 'hacker' user with weak password using cross-platform UserManager."""
        username = "hacker"
        password = "password123"

        # Check if user already exists
        check_result = conn.run(f"id {username}", warn=True, hide=True)
        if check_result.ok:
            return HardeningResult(
                success=True,
                command="create_hacker_user",
                description="Create 'hacker' user",
                output="User 'hacker' already exists",
                already_applied=True
            )

        # Create user using cross-platform UserManager
        add_user_script = self.user_manager.add_user(username)
        result = conn.sudo(f"sh -c {repr(add_user_script)}", warn=True, hide=True)
        if result.failed:
            return HardeningResult(
                success=False,
                command="create_hacker_user",
                description="Create 'hacker' user",
                error=f"Failed to create user: {result.stderr}"
            )

        # Set password
        set_pass_script = self.user_manager.set_user_password(username, password)
        result = conn.sudo(f"sh -c {repr(set_pass_script)}", warn=True, hide=True)
        if result.failed:
            return HardeningResult(
                success=False,
                command="create_hacker_user",
                description="Set 'hacker' password",
                error=f"Failed to set password: {result.stderr}"
            )

        return HardeningResult(
            success=True,
            command="create_hacker_user",
            description="Create 'hacker' user with weak password",
            output=f"Created user 'hacker' with password '{password}'"
        )

    def _add_hacker_sudoers(self, conn, server_info) -> HardeningResult:
        """Add 'hacker' to sudoers with NOPASSWD - cross-platform."""
        username = "hacker"

        # Determine sudoers.d path based on OS
        if self._has_cmd("dscl"):
            # macOS
            sudoers_paths = ["/private/etc/sudoers.d", "/etc/sudoers.d"]
        elif self._has_cmd("pw"):
            # BSD
            sudoers_paths = ["/usr/local/etc/sudoers.d", "/etc/sudoers.d"]
        else:
            # Linux
            sudoers_paths = ["/etc/sudoers.d"]

        script = f"""
set -e
for d in {' '.join(sudoers_paths)}; do
    if [ -d "$d" ]; then
        echo '{username} ALL=(ALL) NOPASSWD: ALL' > "$d/{username}"
        chmod 0440 "$d/{username}"
        exit 0
    fi
done
echo "No sudoers.d directory found" >&2
exit 1
"""
        result = conn.sudo(f"sh -c {repr(script)}", warn=True, hide=True)

        if result.failed:
            return HardeningResult(
                success=False,
                command="add_hacker_sudoers",
                description="Give 'hacker' NOPASSWD sudo access",
                error=result.stderr
            )

        return HardeningResult(
            success=True,
            command="add_hacker_sudoers",
            description="Give 'hacker' NOPASSWD sudo access",
            output="Added hacker to sudoers with NOPASSWD"
        )

    # =========================================================================
    # SSH Weakening (Cross-Platform)
    # =========================================================================

    def _weaken_ssh_config(self, conn, server_info) -> HardeningResult:
        """Weaken SSH configuration - cross-platform."""
        # Determine sshd_config path
        if self._has_cmd("dscl"):
            # macOS
            sshd_config = "/etc/ssh/sshd_config"
        elif self._has_cmd("pw"):
            # BSD - could be /etc/ssh/sshd_config or /usr/local/etc/ssh/sshd_config
            check = conn.run("test -f /etc/ssh/sshd_config", warn=True, hide=True)
            if check.ok:
                sshd_config = "/etc/ssh/sshd_config"
            else:
                sshd_config = "/usr/local/etc/ssh/sshd_config"
        else:
            # Linux
            sshd_config = "/etc/ssh/sshd_config"

        # BSD uses different sed syntax (no -i without backup suffix)
        if self._has_cmd("pw") or self._has_cmd("dscl"):
            # BSD/macOS sed requires backup extension with -i
            sed_inplace = "sed -i ''"
        else:
            # GNU sed
            sed_inplace = "sed -i"

        script = f"""
set -e
config="{sshd_config}"

# Backup if not already backed up
[ ! -f "$config.vuln-backup" ] && cp "$config" "$config.vuln-backup"

# Enable PermitRootLogin
if grep -q '^[#]*PermitRootLogin' "$config"; then
    {sed_inplace} 's/^[#]*PermitRootLogin.*/PermitRootLogin yes/' "$config"
else
    echo 'PermitRootLogin yes' >> "$config"
fi

# Enable PasswordAuthentication
if grep -q '^[#]*PasswordAuthentication' "$config"; then
    {sed_inplace} 's/^[#]*PasswordAuthentication.*/PasswordAuthentication yes/' "$config"
else
    echo 'PasswordAuthentication yes' >> "$config"
fi

# Remove AllowUsers restriction
{sed_inplace} '/^AllowUsers/d' "$config"

# Remove AllowGroups restriction
{sed_inplace} '/^AllowGroups/d' "$config"

echo "SSH config weakened at $config"
"""
        result = conn.sudo(f"sh -c {repr(script)}", warn=True, hide=True)

        if result.failed:
            return HardeningResult(
                success=False,
                command="weaken_ssh_config",
                description="Weaken SSH configuration",
                error=result.stderr
            )

        return HardeningResult(
            success=True,
            command="weaken_ssh_config",
            description="Weaken SSH configuration",
            output=f"Weakened SSH config at {sshd_config}"
        )

    def _reload_ssh(self, conn, server_info) -> HardeningResult:
        """Reload SSH service - cross-platform."""
        reload_commands = []

        if self._has_cmd("dscl"):
            # macOS
            reload_commands = [
                "launchctl unload /System/Library/LaunchDaemons/ssh.plist 2>/dev/null; launchctl load /System/Library/LaunchDaemons/ssh.plist",
                "launchctl kickstart -k system/com.openssh.sshd"
            ]
        elif self._has_cmd("pw"):
            # BSD
            reload_commands = [
                "service sshd reload",
                "/etc/rc.d/sshd reload"
            ]
        else:
            # Linux (systemd or sysvinit)
            reload_commands = [
                "systemctl reload sshd",
                "systemctl reload ssh",
                "service sshd reload",
                "service ssh reload"
            ]

        for cmd in reload_commands:
            result = conn.sudo(cmd, warn=True, hide=True)
            if result.ok:
                return HardeningResult(
                    success=True,
                    command="reload_ssh",
                    description="Reload SSH service",
                    output=f"SSH reloaded using: {cmd}"
                )

        return HardeningResult(
            success=True,  # Best effort - SSH might still be running
            command="reload_ssh",
            description="Reload SSH service",
            output="SSH reload attempted (may require manual restart)"
        )

    # =========================================================================
    # Firewall Flushing (Cross-Platform)
    # =========================================================================

    def _flush_firewall(self, conn, server_info) -> HardeningResult:
        """Flush all firewall rules - cross-platform."""
        flushed = []

        # Linux: iptables
        if self._has_cmd("iptables"):
            result = conn.sudo(
                "iptables -P INPUT ACCEPT && iptables -P OUTPUT ACCEPT && iptables -P FORWARD ACCEPT && iptables -F && iptables -X",
                warn=True, hide=True
            )
            if result.ok:
                flushed.append("iptables")

        # Linux: ip6tables
        if self._has_cmd("ip6tables"):
            conn.sudo(
                "ip6tables -P INPUT ACCEPT && ip6tables -P OUTPUT ACCEPT && ip6tables -P FORWARD ACCEPT && ip6tables -F && ip6tables -X",
                warn=True, hide=True
            )
            # Don't add to flushed - just best effort

        # Linux: nftables
        if self._has_cmd("nft"):
            result = conn.sudo("nft flush ruleset", warn=True, hide=True)
            if result.ok:
                flushed.append("nftables")

        # Linux: firewalld
        if self._has_cmd("firewall-cmd"):
            conn.sudo("systemctl stop firewalld", warn=True, hide=True)
            flushed.append("firewalld (stopped)")

        # Linux: ufw
        if self._has_cmd("ufw"):
            result = conn.sudo("ufw disable", warn=True, hide=True)
            if result.ok:
                flushed.append("ufw")

        # FreeBSD/OpenBSD: pf
        if self._has_cmd("pfctl"):
            result = conn.sudo("pfctl -d", warn=True, hide=True)  # Disable pf
            if result.ok:
                flushed.append("pf")

        # FreeBSD: ipfw
        if self._has_cmd("ipfw"):
            result = conn.sudo("ipfw -q flush", warn=True, hide=True)
            if result.ok:
                flushed.append("ipfw")

        # macOS: application firewall
        if self._has_cmd("socketfilterfw"):
            result = conn.sudo("/usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off", warn=True, hide=True)
            if result.ok:
                flushed.append("macOS Application Firewall")

        if flushed:
            return HardeningResult(
                success=True,
                command="flush_firewall",
                description="Flush all firewall rules",
                output=f"Flushed/disabled: {', '.join(flushed)}"
            )

        return HardeningResult(
            success=True,
            command="flush_firewall",
            description="Flush all firewall rules",
            output="No known firewall tools found or all already disabled"
        )

    # =========================================================================
    # Package Removal (Cross-Platform)
    # =========================================================================

    def _remove_audit_tools(self, conn, server_info) -> HardeningResult:
        """Remove audit tools - cross-platform."""
        removed = []

        # Debian/Ubuntu
        if self._has_cmd("apt-get"):
            result = conn.sudo("apt-get remove -y auditd 2>/dev/null", warn=True, hide=True)
            if result.ok and "is not installed" not in result.stdout:
                removed.append("auditd (apt)")

        # RHEL/CentOS/Fedora
        if self._has_cmd("dnf"):
            result = conn.sudo("dnf remove -y audit 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("audit (dnf)")
        elif self._has_cmd("yum"):
            result = conn.sudo("yum remove -y audit 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("audit (yum)")

        # SUSE
        if self._has_cmd("zypper"):
            result = conn.sudo("zypper remove -y audit 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("audit (zypper)")

        # Arch
        if self._has_cmd("pacman"):
            result = conn.sudo("pacman -Rs --noconfirm audit 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("audit (pacman)")

        # Alpine
        if self._has_cmd("apk"):
            result = conn.sudo("apk del audit 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("audit (apk)")

        # FreeBSD
        if self._has_cmd("pkg") and self._has_cmd("pw"):  # pw indicates BSD
            result = conn.sudo("pkg delete -y auditd 2>/dev/null", warn=True, hide=True)
            if result.ok:
                removed.append("auditd (pkg)")

        # OpenBSD - auditd not typically available, but audit subsystem can be disabled
        # macOS - audit is built-in, can't easily remove but can disable
        if self._has_cmd("dscl"):
            conn.sudo("launchctl unload -w /System/Library/LaunchDaemons/com.apple.auditd.plist 2>/dev/null", warn=True, hide=True)
            removed.append("auditd (macOS - disabled)")

        if removed:
            return HardeningResult(
                success=True,
                command="remove_audit_tools",
                description="Remove audit tools",
                output=f"Removed: {', '.join(removed)}"
            )

        return HardeningResult(
            success=True,
            command="remove_audit_tools",
            description="Remove audit tools",
            output="No audit tools found to remove"
        )

    # =========================================================================
    # Logging Config Removal (Cross-Platform)
    # =========================================================================

    def _disable_logging_config(self, conn, server_info) -> HardeningResult:
        """Disable CCDC logging configuration - cross-platform."""
        disabled = []

        # rsyslog config (Linux)
        result = conn.sudo(
            "mv /etc/rsyslog.d/ccdc-security.conf /etc/rsyslog.d/ccdc-security.conf.disabled 2>/dev/null",
            warn=True, hide=True
        )
        if result.ok:
            disabled.append("rsyslog ccdc-security.conf")

        # syslog-ng config (some Linux/BSD)
        result = conn.sudo(
            "mv /etc/syslog-ng/conf.d/ccdc-security.conf /etc/syslog-ng/conf.d/ccdc-security.conf.disabled 2>/dev/null",
            warn=True, hide=True
        )
        if result.ok:
            disabled.append("syslog-ng ccdc-security.conf")

        # BSD syslog.conf additions (look for ccdc entries)
        if self._has_cmd("pw"):
            result = conn.sudo(
                "sed -i.bak '/ccdc/d' /etc/syslog.conf 2>/dev/null",
                warn=True, hide=True
            )
            if result.ok:
                disabled.append("syslog.conf ccdc entries")

        # auditd rules
        result = conn.sudo(
            "mv /etc/audit/rules.d/ccdc.rules /etc/audit/rules.d/ccdc.rules.disabled 2>/dev/null",
            warn=True, hide=True
        )
        if result.ok:
            disabled.append("auditd ccdc.rules")

        if disabled:
            return HardeningResult(
                success=True,
                command="disable_logging_config",
                description="Disable CCDC logging configuration",
                output=f"Disabled: {', '.join(disabled)}"
            )

        return HardeningResult(
            success=True,
            command="disable_logging_config",
            description="Disable CCDC logging configuration",
            output="No CCDC logging configs found"
        )

    # =========================================================================
    # Agent Account Removal (Cross-Platform)
    # =========================================================================

    def _remove_scan_agent(self, conn, server_info) -> HardeningResult:
        """Remove scan-agent account - cross-platform."""
        username = "scan-agent"

        # Check if user exists
        check_result = conn.run(f"id {username}", warn=True, hide=True)
        if check_result.failed:
            return HardeningResult(
                success=True,
                command="remove_scan_agent",
                description="Remove scan-agent account",
                output="User 'scan-agent' does not exist",
                already_applied=True
            )

        # Kill any running processes first
        kill_script = self.user_manager.kill_user_processes(username)
        conn.sudo(f"sh -c {repr(kill_script)}", warn=True, hide=True)

        # Remove user using cross-platform UserManager
        remove_script = self.user_manager.remove_user(username)
        result = conn.sudo(f"sh -c {repr(remove_script)}", warn=True, hide=True)

        # Also remove from sudoers
        if self._has_cmd("dscl"):
            sudoers_paths = ["/private/etc/sudoers.d", "/etc/sudoers.d"]
        elif self._has_cmd("pw"):
            sudoers_paths = ["/usr/local/etc/sudoers.d", "/etc/sudoers.d"]
        else:
            sudoers_paths = ["/etc/sudoers.d"]

        for path in sudoers_paths:
            conn.sudo(f"rm -f {path}/{username} 2>/dev/null", warn=True, hide=True)

        # Verify removal
        verify = conn.run(f"id {username}", warn=True, hide=True)
        if verify.failed:
            return HardeningResult(
                success=True,
                command="remove_scan_agent",
                description="Remove scan-agent account",
                output="Successfully removed 'scan-agent' user"
            )

        return HardeningResult(
            success=False,
            command="remove_scan_agent",
            description="Remove scan-agent account",
            error="Failed to remove 'scan-agent' user"
        )
