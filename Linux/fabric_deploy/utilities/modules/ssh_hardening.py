"""
SSH hardening module for CCDC framework
Enhanced with proper backup/rollback and connection testing
"""

import json
import logging
import os
import time
from datetime import datetime
from typing import List, Set
from fabric import Connection, Config
from .base import HardeningModule, HardeningCommand, PythonAction, HardeningResult
from ..discovery import OSFamily

ROOT_KEY_PATH = os.path.join(os.path.dirname(__file__), "/home/antimony/Desktop/cyber/repos/MSU-BlueScripts/Linux/fabric_deploy/keys/test-root-key.private")

logger = logging.getLogger(__name__)

# if the version is old add lines: 
# UsePrivilegeSeparation sandbox
# Protocol 2


class SSHHardeningModule(HardeningModule):
    """SSH hardening commands with backup, rollback, and connection testing"""
    
    def __init__(self, connection, server_info, os_family):
        super().__init__(connection, server_info, os_family)
        self.users_config = self._load_users_config()
        self.allowed_users = self._get_allowed_users()
        self.trapped_users = self._get_trapped_users()
        self.allowed_users = self.allowed_users | set(self.trapped_users)
        self.dead_mans_switch_pid = None
    
    def get_name(self) -> str:
        return "ssh_hardening"
    
    def _load_users_config(self):
        """Load users configuration from users.json"""
        config_path = os.path.join(os.path.dirname(__file__), "../../users.json")
        try:
            with open(config_path, "r") as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning("users.json not found at %s", config_path)
            return {
                "regular_users": {},
                "super_users": {},
                "do_not_change_users": {"root": "system account"}
            }
        except json.JSONDecodeError as exc:
            logger.error("users.json is invalid: %s", exc)
            return {
                "regular_users": {},
                "super_users": {},
                "do_not_change_users": {"root": "system account"}
            }
    
    def _get_user_set(self, key: str) -> Set[str]:
        """Extract user set from config (handles dict or list)"""
        value = self.users_config.get(key, {})
        if isinstance(value, dict):
            return set(value.keys())
        elif isinstance(value, list):
            return set(value)
        return set()
    
    def _get_allowed_users(self) -> Set[str]:
        """Get all users that should be allowed to SSH (not trapped)"""
        regular = self._get_user_set("regular_users")
        super_users = self._get_user_set("super_users")
        do_not_change = self._get_user_set("do_not_change_users")
        return regular | super_users | do_not_change
    
    def _get_trapped_users(self) -> List[str]:
        """Get the 2 longest usernames from non-allowed users (likely not system accounts)"""
        current_valid_users = {
            user.username for user in self.server_info.users if user.valid_shell
        }
        non_allowed = current_valid_users - self.allowed_users
        # Sort by length (descending) then alphabetically, and take the top 2
        sorted_users = sorted(non_allowed, key=lambda u: (-len(u), u))
        trapped = sorted_users[:2]
        logger.info(f"Selected {len(trapped)} users for SSH honeypot trapping: {','.join(trapped)}")
        return trapped
    
    def _generate_ssh_config(self) -> str:
        """Generate the complete SSH hardening configuration"""
        # Include both allowed users AND trapped users in AllowUsers directive
        all_allowed = sorted(self.allowed_users | set(self.trapped_users))
        allowed_users_str = " ".join(all_allowed)
        
        config = f"""# ===== BEGIN SSH HARDENING CONFIG FABRIC EDITION V 1.0 =====
# Generated by MSU-BlueScripts SSH Hardening Module
# Do not manually edit this section

# Core Security Settings
Protocol 2
PermitRootLogin prohibit-password
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PermitEmptyPasswords no
ChallengeResponseAuthentication no
PasswordAuthentication yes

# Disable Legacy/Insecure Features
IgnoreRhosts yes
HostbasedAuthentication no
X11Forwarding no

# Authentication & Session Settings
MaxAuthTries 1
LoginGraceTime 60s
ClientAliveInterval 300
ClientAliveCountMax 2

# System Integration
UsePAM yes
SyslogFacility AUTH
AcceptEnv LANG LC_*

# User Access Control (includes trapped honeypot users)
AllowUsers {allowed_users_str}

# ===== END SSH HARDENING CONFIG =====

"""
        return config
    
    def _generate_trap_config(self) -> str:
        trapped_users_str = ','.join(self.trapped_users)
        return f"""Match User {trapped_users_str}
    ForceCommand env -u $(env | cut -d= -f1) /bin/honeypot
    ChrootDirectory none
    AllowTcpForwarding no 
    X11Forwarding no 
    PermitTunnel no 
    GatewayPorts no 
    AllowAgentForwarding no 
    PermitOpen none
"""

    def get_commands(self) -> List[HardeningCommand]:
        commands = []
        
        # Create backup with timestamp and store backup path
        backup_file = f"/etc/ssh/sshd_config.fabric.backup"
        
        # 1. Safer Backup Creation
        # Check if the backup already exists, if it does do nothing to preserve the original state before ANY fabric runs
        commands.append(HardeningCommand(
            command=f"test -f {backup_file} && echo 'Backup {backup_file} already exists, skipping' || (cp /etc/ssh/sshd_config {backup_file} && echo 'Backup created: {backup_file}')",
            description="Create timestamped SSH configuration backup (if not exists)",
            check_command=f"ls {backup_file} >/dev/null 2>&1 && echo backup_exists",
            requires_sudo=True
        ))

        # 2. Original Config Validation & Fallback
        # Validate original config. If invalid, backup as broken and assert a minimal valid config.
        # We first write and test the minimal config to ensure sshd -t itself is working.
        minimal_config = "Protocol 2\\nPermitRootLogin prohibit-password\\nPasswordAuthentication yes\\nPubkeyAuthentication yes\\nSubsystem sftp /usr/lib/openssh/sftp-server"
        minimal_file = "/etc/ssh/sshd_config.minimal.config"
        broken_backup = f"{backup_file}.original.broken"
        
        validate_and_fix_cmd = (
            # 1. Create minimal file
            f"printf '{minimal_config}' > {minimal_file} && "
            f"chmod 644 {minimal_file} && "
            # 2. Test minimal file (verifies sshd -t works)
            f"sshd -t -f {minimal_file} && "
            # 3. Check original config
            f"(sshd -t -f /etc/ssh/sshd_config && echo 'Original config valid' || "
            # 4. Fallback if original broken using the verified minimal file
            f"(echo 'Original config BROKEN. Backing up and resetting...' && "
            f"cp /etc/ssh/sshd_config {broken_backup} && "
            f"cp {minimal_file} /etc/ssh/sshd_config && "
            f"echo 'Reset to minimal valid config'))"
        )
        
        commands.append(HardeningCommand(
            command=validate_and_fix_cmd,
            description="Validate original SSH configuration (reset to minimal if broken, verifies check command first)",
            requires_sudo=True
        ))
        
        # Generate and prepend hardening config
        hardening_config = self._generate_ssh_config()
        commands.append(PythonAction(
            function=self._prepend_ssh_config,
            description="Prepend hardening configuration to sshd_config",
            args=(hardening_config,),
            requires_sudo=True
        ))
        
        # Append trapped users Match blocks to end of config (if any)
        trap_config = self._generate_trap_config()
        if self.trapped_users:
            commands.append(PythonAction(
                function=self._append_trapped_users,
                description=f"Append honeypot traps for users: {', '.join(self.trapped_users)}",
                args=(trap_config,),
                requires_sudo=True
            ))
                
        # Arm Dead Man's Switch before reload
        commands.append(PythonAction(
            function=self._arm_dead_mans_switch,
            description="Arm Dead Man's Switch (60s fuse)",
            args=(backup_file,),
            requires_sudo=True
        ))

        # Ensure SSH is enabled at boot
        enable_cmd = self._get_ssh_enable_command()
        commands.append(HardeningCommand(
            command=enable_cmd,
            description="Ensure SSH service is enabled at boot",
            requires_sudo=True
        ))

        # Mark as safe to reboot ONLY if we get here (meaning test checks passed)
        commands.append(PythonAction(
            function=self._set_reboot_safety,
            description="Signal that reboot is safe",
            requires_sudo=False
        ))

        # 4. Combined Validation and Reload
        # Combine these into one task so that if the validation of new config fails we don't proceed with reloading the ssh service
        reload_cmd = self._get_ssh_reload_command()
        commands.append(HardeningCommand(
            command=f"sshd -t -f /etc/ssh/sshd_config && echo 'New config valid' && {reload_cmd}",
            description="Validate new SSH configuration and reload service",
            requires_sudo=True
        ))
                
        # Test SSH connectivity with Python function
        commands.append(PythonAction(
            function=self._test_ssh_connectivity,
            description="Test SSH connectivity after changes",
            requires_sudo=False
        ))
                
        return commands

    def _append_trapped_users(self, conn, server_info, trap_config ):
        """append hardening config to /etc/ssh/sshd_config"""
        try:
            # Read current config
            result = conn.sudo("cat /etc/ssh/sshd_config", hide=True, warn=True)
            if not result.ok:
                return HardeningResult(
                    success=False,
                    command="append_trap_sshd",
                    description="Read current sshd_config",
                    output="",
                    error=f"Failed to read sshd_config: {result.stderr}"
                )

            trap_config  = self._generate_trap_config()

            write_result = conn.sudo(
                f"printf '%s' '{trap_config}' >> /etc/ssh/sshd_config",
                hide=True,
                warn=True
            )
            
            if not write_result.ok:
                return HardeningResult(
                    success=False,
                    command="append_trap_sshd",
                    description="append config to file",
                    output="",
                    error=f"Failed to append trap config: {write_result.stderr}"
                )
                        
            trapped_count = len(self.trapped_users)
            
            return HardeningResult(
                success=True,
                command="append_trap_sshd",
                description="Prepend hardening configuration to sshd_config",
                output=f"Successfully appened SSH trapping config. Trapped users: {trapped_count}"
            )
            
        except Exception as e:
            logger.error(f"Error prepending SSH config: {e}")
            return HardeningResult(
                success=False,
                command="append_trap_sshd",
                description="Prepend hardening configuration to sshd_config",
                output="",
                error=str(e)
            )

    def _prepend_ssh_config(self, conn, server_info, hardening_config: str):
        """Prepend hardening config to /etc/ssh/sshd_config"""
        try:
            # 3. Idempotency Check
            # Read first line to see if already hardened
            HARDENING_HEADER = "# ===== BEGIN SSH HARDENING CONFIG FABRIC EDITION V 1.0 ====="
            head_result = conn.sudo("head -n 1 /etc/ssh/sshd_config", hide=True, warn=True)
            
            if head_result.ok and head_result.stdout.strip() == HARDENING_HEADER:
                return HardeningResult(
                    success=True,
                    command="prepend_ssh_config",
                    description="Prepend hardening configuration",
                    output="SSH config already hardened (idempotency check passed)"
                )

            # Read current config
            result = conn.sudo("cat /etc/ssh/sshd_config", hide=True, warn=True)
            if not result.ok:
                return HardeningResult(
                    success=False,
                    command="prepend_ssh_config",
                    description="Read current sshd_config",
                    output="",
                    error=f"Failed to read sshd_config: {result.stderr}"
                )
            
            current_config = result.stdout
            
            # Combine: hardening config + original config
            new_config = hardening_config + current_config
            
            # Write to temporary file first
            temp_file = "/tmp/sshd_config.new"
            
            # Escape special characters for shell
            escaped_config = new_config.replace("'", "'\"'\"'")
            
            write_result = conn.sudo(
                f"printf '%s' '{escaped_config}' > {temp_file}",
                hide=True,
                warn=True
            )
            
            if not write_result.ok:
                return HardeningResult(
                    success=False,
                    command="prepend_ssh_config",
                    description="Write new config to temp file",
                    output="",
                    error=f"Failed to write temp config: {write_result.stderr}"
                )
            
            # Move temp file to actual location
            move_result = conn.sudo(
                f"mv {temp_file} /etc/ssh/sshd_config && chmod 644 /etc/ssh/sshd_config",
                hide=True,
                warn=True
            )
            
            if not move_result.ok:
                return HardeningResult(
                    success=False,
                    command="prepend_ssh_config",
                    description="Move new config to /etc/ssh/sshd_config",
                    output="",
                    error=f"Failed to move config: {move_result.stderr}"
                )
            
            allowed_count = len(self.allowed_users)
            
            return HardeningResult(
                success=True,
                command="prepend_ssh_config",
                description="Prepend hardening configuration to sshd_config",
                output=f"Successfully prepended SSH hardening config. Allowed users: {allowed_count}"
            )
            
        except Exception as e:
            logger.error(f"Error prepending SSH config: {e}")
            return HardeningResult(
                success=False,
                command="prepend_ssh_config",
                description="Prepend hardening configuration to sshd_config",
                output="",
                error=str(e)
            )
    
    def _arm_dead_mans_switch(self, conn, server_info, backup_file):
        """Start a background process that reverts changes after 60s unless killed"""
        try:
            reload_cmd = self._get_ssh_reload_command()
            # Complex shell command to sleep, restore, and reload
            # We use nohup to ensure it survives connection loss
            
            revert_cmd = (
                f"sleep 60 && "
                f"mv {backup_file} /etc/ssh/sshd_config && "
                f"{reload_cmd} && "
                f"echo 'Dead mans switch triggered: reverted SSH config'"
            )
            
            # Wrap in a way that gives us the PID of the sleep process or the shell
            # We want to be able to kill this entire chain.
            # Using a subshell in background: ( ... ) & echo $!
            
            full_cmd = f"nohup sh -c \"{revert_cmd}\" >/dev/null 2>&1 & echo $!"
            
            result = conn.sudo(full_cmd, hide=True)
            if result.ok and result.stdout.strip().isdigit():
                self.dead_mans_switch_pid = result.stdout.strip()
                logger.info(f"Armed Dead Man's Switch with PID: {self.dead_mans_switch_pid}")
                return HardeningResult(
                    success=True,
                    command="arm_dead_mans_switch",
                    description="Armed Dead Man's Switch",
                    output=f"Armed with PID {self.dead_mans_switch_pid}"
                )
            else:
                return HardeningResult(
                    success=False,
                    command="arm_dead_mans_switch",
                    description="Arm Dead Man's Switch",
                    output="",
                    error=f"Failed to get PID: {result.stderr}"
                )
        except Exception as e:
            return HardeningResult(
                success=False,
                command="arm_dead_mans_switch",
                description="Arm Dead Man's Switch",
                output="",
                error=str(e)
            )

    def _test_ssh_connectivity(self, conn, server_info):
        """Test SSH connectivity after configuration changes with automatic rollback on failure"""
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Get connection details from server_info
            host = server_info.credentials.host
            user = server_info.credentials.user
            port = getattr(server_info.credentials, 'port', 22)
            password = getattr(server_info.credentials, 'password', None)
            key_file = getattr(server_info.credentials, 'key_file', None)
            
            logger.info(f"Testing SSH connectivity to {host}:{port} as {user}")
            
            # Set up connection configuration
            connect_kwargs = {'allow_agent': False, 'look_for_keys': False}
            config_overrides = {
                'sudo': {'password': password},
                'load_ssh_configs': False
            }
            
            # Special handling for root user - use the designated root key if available
            # This is critical because after hardening, root password login is disabled
            if user == 'root' and os.path.exists(ROOT_KEY_PATH):
                logger.info(f"Using root recovery key for connectivity test: {ROOT_KEY_PATH}")
                # We prioritize this key. If lists are supported, we could append, 
                # but for simplicity/reliability we'll set it as the primary key if it exists.
                # Fabric/Paramiko can handle a list of keys in key_filename too.
                current_keys = []
                if key_file:
                     if isinstance(key_file, list):
                         current_keys.extend(key_file)
                     else:
                         current_keys.append(key_file)
                
                # Prepend the root key
                current_keys.insert(0, ROOT_KEY_PATH)
                connect_kwargs['key_filename'] = current_keys
                
                # If we have a key, we might not strictly need the password for auth,
                # but we keep it for sudo if needed (though root usually doesn't need password for sudo)
                if password:
                    connect_kwargs['password'] = password

            else:
                 # Standard logic
                if key_file:
                    connect_kwargs['key_filename'] = key_file
                elif password:
                    connect_kwargs['password'] = password
                
            if port != 22:
                connect_kwargs['port'] = port
                
            config = Config(overrides=config_overrides)
            
            # Test new connection with a timeout
            test_success = False
            error_msg = None
            
            try:
                with Connection(host, user=user, config=config, connect_kwargs=connect_kwargs) as test_conn:
                    # Simple connectivity test
                    result = test_conn.run('echo "SSH test successful"', hide=True, warn=True, timeout=10)
                    test_success = result.ok
                    if not test_success:
                        error_msg = f"SSH test command failed: {result.stderr}"
                        
            except Exception as e:
                test_success = False
                error_msg = f"SSH connection failed: {str(e)}"
                
            if test_success:
                msg = "SSH connectivity test successful - new configuration is working"
                
                # Disarm Dead Man's Switch
                if self.dead_mans_switch_pid:
                    # Kill the background process (usually sleep or sh)
                    # We kill the process group or just the pid
                    conn.sudo(f"kill {self.dead_mans_switch_pid} || true", hide=True, warn=True)
                    logger.info(f"Disarmed Dead Man's Switch (PID {self.dead_mans_switch_pid})")
                    msg += " | Dead Man's Switch Disarmed"
                
                return HardeningResult(
                    success=True,
                    command="python_function:_test_ssh_connectivity",
                    description="Test SSH connectivity after changes",
                    output=msg
                )
            else:
                # Connection failed - attempt automatic rollback
                logger.warning(f"SSH connectivity test failed: {error_msg}")
                logger.info("Attempting automatic rollback of SSH configuration...")
                
                # Find the most recent backup
                backup_result = conn.run("ls -t /etc/ssh/sshd_config.backup.* 2>/dev/null | head -1", 
                                       hide=True, warn=True)
                
                if backup_result.ok and backup_result.stdout.strip():
                    backup_file = backup_result.stdout.strip()
                    logger.info(f"Found backup file: {backup_file}")
                    
                    # Restore the backup
                    restore_result = conn.sudo(f"cp {backup_file} /etc/ssh/sshd_config", 
                                             hide=True, warn=True)
                    
                    if restore_result.ok:
                        # Restart SSH service
                        reload_cmd = self._get_ssh_reload_command()
                        restart_result = conn.sudo(reload_cmd, hide=True, warn=True)
                        
                        if restart_result.ok:
                            logger.info("SSH configuration rolled back successfully")
                            
                            # Also disarm the switch since we rolled back manually
                            if self.dead_mans_switch_pid:
                                conn.sudo(f"kill {self.dead_mans_switch_pid} || true", hide=True, warn=True)
                            
                            return HardeningResult(
                                success=False,
                                command="python_function:_test_ssh_connectivity",
                                description="Test SSH connectivity after changes",
                                output="SSH test failed, configuration rolled back automatically",
                                error=f"Original error: {error_msg}. Rollback completed successfully."
                            )
                        else:
                            logger.error("Failed to restart SSH service after rollback")
                    else:
                        logger.error("Failed to restore SSH configuration backup")
                else:
                    logger.error("No SSH configuration backup found for rollback")
                
                # If we get here, manual rollback failed or no backup found.
                # Hopefully the Dead Man's Switch will save us in <60s.
                return HardeningResult(
                    success=False,
                    command="python_function:_test_ssh_connectivity",
                    description="Test SSH connectivity after changes",
                    output="SSH connectivity test failed",
                    error=f"SSH test failed: {error_msg}. Manual intervention may be required. Dead Man's Switch active."
                )
                
        except Exception as e:
            logger.error(f"SSH connectivity test encountered an error: {e}")
            return HardeningResult(
                success=False,
                command="python_function:_test_ssh_connectivity",
                description="Test SSH connectivity after changes",
                output="SSH connectivity test encountered an error",
                error=str(e)
            )
    
    def _get_ssh_reload_command(self) -> str:
        """Get the appropriate SSH reload command (tries both ssh and sshd)"""
        try:
            init_system = getattr(self.server_info, 'init_system', 'unknown')
            
            # Helper to construct "reload OR restart" for a service name
            def cmd_for(srv, sys_type):
                if sys_type == "systemd":
                    return f"(systemctl reload {srv} || sudo systemctl restart {srv})"
                elif sys_type == "openrc":
                    return f"(rc-service {srv} reload || sudo rc-service {srv} restart)"
                elif sys_type == "bsd":
                    return f"service {srv} reload"
                elif sys_type == "sysvinit":
                     return f"(service {srv} reload || /etc/init.d/{srv} reload)"
                else: 
                     # Fallback "spray and pray" chain
                     # Includes: systemd, openrc, bsd, sysvinit, slackware
                     return (
                         f"(service {srv} reload || "
                         f"systemctl restart {srv} || "
                         f"/etc/init.d/{srv} restart || "
                         f"rc-service {srv} restart || "
                         f"/etc/rc.d/rc.{srv} restart)"
                     )

            # Generate commands for both 'ssh' and 'sshd'
            # We chain them with OR (||) so if 'ssh' fails (e.g. not found), 'sshd' runs.
            # If 'sshd' succeeds, we are done.
            ssh_cmd = cmd_for("ssh", init_system)
            sshd_cmd = cmd_for("sshd", init_system)
            
            return f"{sshd_cmd} || {ssh_cmd} "

        except Exception as e:
            logger.warning(f"Error determining SSH reload command: {e}")
            # Robust fallback
            return "(service ssh reload || service sshd reload || systemctl restart sshd || /etc/rc.d/rc.sshd restart)"

    def _set_reboot_safety(self, conn, server_info) -> HardeningResult:
        """Mark the server as safe to reboot (SSH is verified working)"""
        server_info.safe_to_reboot = True
        return HardeningResult(
            success=True,
            command="python_function:_set_reboot_safety",
            description="Mark server as safe to reboot",
            output="Server marked as safe to reboot"
        )

    def _get_ssh_enable_command(self) -> str:
        """Get the appropriate command to enable SSH at boot"""
        try:
            init_system = getattr(self.server_info, 'init_system', 'unknown')
            
            def cmd_for(srv, sys_type):
                if sys_type == "systemd":
                    return f"systemctl enable {srv}"
                elif sys_type == "openrc":
                    return f"rc-update add {srv} default"
                elif sys_type == "bsd":
                    # sysrc for FreeBSD/NetBSD, rcctl for OpenBSD
                    return f"(sysrc sshd_enable=YES || rcctl enable {srv})"
                elif sys_type == "sysvinit":
                     # generic sysvinit fallback (Debian/RedHat legacy)
                     return f"(update-rc.d {srv} defaults || chkconfig {srv} on)"
                else: 
                     # Fallback "spray and pray" chain
                     # Includes: systemd, openrc, debian-sysv, redhat-sysv, bsd, slackware
                     return (
                         f"(systemctl enable {srv} || "
                         f"rc-update add {srv} default || "
                         f"update-rc.d {srv} defaults || "
                         f"chkconfig {srv} on || "
                         f"sysrc sshd_enable=YES || "
                         f"chmod +x /etc/rc.d/rc.{srv})"
                     )

            ssh_cmd = cmd_for("ssh", init_system)
            sshd_cmd = cmd_for("sshd", init_system)
            
            return f"{sshd_cmd} || {ssh_cmd}"

        except Exception as e:
            logger.warning(f"Error determining SSH enable command: {e}")
            return "systemctl enable sshd || rc-update add sshd default || chmod +x /etc/rc.d/rc.sshd"
